import tkinter as tk
from tkinter import filedialog, messagebox
from tkcalendar import Calendar
import pandas as pd
from datetime import datetime
import os
import tempfile


def calculate_amortization(start_date, current_date, value):
    """
    Calculate the remaining amortized value.

    Args:
        start_date (datetime): Start date of the amortization period.
        current_date (datetime): Current date for which amortization is calculated.
        value (float): The value to amortize.

    Returns:
        float: Remaining amortized value.
    """
    # Calculate fraction of the year passed
    fraction_year_passed = (current_date - start_date).days / 365
    # Convert to months
    months_passed = fraction_year_passed * 12
    # Calculate remaining value
    remaining_value = max(0, value * (12 - months_passed) / 12)
    return remaining_value


class StatementGeneratorApp:
    """
    Main application for processing financial statements.
    """
    def __init__(self, root):
        self.root = root
        self.root.title("Statement Generator")

        # File paths
        self.main_file_path = None  # Path to the main file
        self.moved_file_path = None  # Path to the moved file (CSV)

        # Main File Selector
        tk.Label(root, text="Main File:").grid(row=0, column=0, padx=10, pady=5)
        self.main_file_label = tk.Label(root, text="No file selected")
        self.main_file_label.grid(row=0, column=1, padx=10, pady=5)
        tk.Button(root, text="Browse", command=self.select_main_file).grid(row=0, column=2, padx=10, pady=5)

        # Moved File Selector
        tk.Label(root, text="Moved File (CSV):").grid(row=1, column=0, padx=10, pady=5)
        self.moved_file_label = tk.Label(root, text="No file selected")
        self.moved_file_label.grid(row=1, column=1, padx=10, pady=5)
        tk.Button(root, text="Browse", command=self.select_moved_file).grid(row=1, column=2, padx=10, pady=5)

        # Date Selector
        tk.Label(root, text="Date:").grid(row=2, column=0, padx=10, pady=5)
        self.date_picker = Calendar(root, selectmode="day", date_pattern="yyyy-mm-dd")
        self.date_picker.grid(row=2, column=1, columnspan=2, padx=10, pady=5)

        # Process Button
        tk.Button(root, text="Process Files", command=self.process_files).grid(row=3, column=1, padx=10, pady=10)

    def select_main_file(self):
        """
        Opens a file dialog for the user to select the main file.
        """
        self.main_file_path = filedialog.askopenfilename(filetypes=[("Excel files", "*.xlsx")])
        if self.main_file_path:
            self.main_file_label.config(text=self.main_file_path)

    def select_moved_file(self):
        """
        Opens a file dialog for the user to select the moved file (CSV).
        """
        self.moved_file_path = filedialog.askopenfilename(filetypes=[("CSV files", "*.csv")])
        if self.moved_file_path:
            self.moved_file_label.config(text=self.moved_file_path)

    def process_files(self):
        """
        Processes the main file and the moved file.
        Flips the sign of PV and displays the results in Excel.
        """
        # Validate inputs
        if not self.main_file_path or not self.moved_file_path:
            messagebox.showerror("Error", "Please ensure both main and moved files are selected.")
            return

        try:
            # Load main file (Excel)
            main_data = pd.read_excel(self.main_file_path)

            # Load moved file (CSV)
            moved_data = pd.read_csv(self.moved_file_path)

            # Ensure TRADEIDENTIFIER matches (use only the first 7 characters)
            moved_data['TRADEIDENTIFIER'] = moved_data['TRADEIDENTIFIER'].str[:7]
            main_data['TRADEIDENTIFIER'] = main_data['TRADEIDENTIFIER'].astype(str)
            moved_data['TRADEIDENTIFIER'] = moved_data['TRADEIDENTIFIER'].astype(str)

            # Merge PV from moved file into main file
            main_data = main_data.merge(
                moved_data[['TRADEIDENTIFIER', 'PV']],
                on='TRADEIDENTIFIER',
                how='left'
            )

            # Flip the sign of the PV values
            main_data['PV'] = main_data['PV'] * -1

            # Get the selected date for processing
            current_date = datetime.strptime(self.date_picker.get_date(), "%Y-%m-%d")

            # Process each row for calculations
            def calculate_adjusted_values(row):
                if pd.notna(row['P&L']) and pd.notna(row['TRADE DATE']):
                    start_date = pd.to_datetime(row['TRADE DATE'])
                    value_to_amortize = row['P&L']
                    adjusted_pnl = calculate_amortization(start_date, current_date, value_to_amortize)
                    combined_value = row['PV'] + adjusted_pnl  # Keep full precision
                    spread = row.get('SPREAD', 0)
                    bid = combined_value - (2 / 3) * spread
                    offer = combined_value + (1 / 3) * spread
                    return pd.Series([adjusted_pnl, combined_value, bid, offer])
                return pd.Series([None, None, None, None])

            # Apply calculations to all rows
            main_data[['Adjusted_P&L', 'Combined_Value', 'Bid', 'Offer']] = main_data.apply(
                calculate_adjusted_values, axis=1
            )

            # Open the processed data in Excel
            self.display_in_excel(main_data)

        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}")

    def display_in_excel(self, dataframe):
        """
        Displays the processed DataFrame in Excel without saving it.
        """
        with tempfile.NamedTemporaryFile(delete=False, suffix=".xlsx") as tmp:
            temp_filename = tmp.name
            with pd.ExcelWriter(temp_filename, engine='openpyxl') as writer:
                dataframe.to_excel(writer, index=False, sheet_name="Processed Data")

            # Open the file in the default Excel application
            os.startfile(temp_filename)


# Run the app
if __name__ == "__main__":
    root = tk.Tk()
    app = StatementGeneratorApp(root)
    root.mainloop()

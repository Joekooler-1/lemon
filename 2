import tkinter as tk
from tkinter import filedialog, messagebox, ttk
from tkcalendar import Calendar
import pandas as pd
from datetime import datetime
import os
import tempfile
from openpyxl.styles import numbers


# Constants for default values
DEFAULT_VALUES = {
    "Sub Product": "CRA SWAP",
    "PAYER": "CHANGE",
    "Pay": "Float",
    "Pay Frequency": "1MO",
    "Pay CCY": "USD",
    "Receive": "Float",
    "Receive Index": "USD SOFR",
    "Receive Rate": "0.3",
    "Receive Frequency": "1MO",
    "Receive CCY": "USD",
}

DATE_COLUMNS = {"TRADE DATE", "Effective Date", "Maturity Date"}  # Columns that need date formatting


def calculate_amortization(start_date, current_date, value):
    """
    Calculate the remaining amortized value based on time elapsed.
    """
    fraction_year_passed = (current_date - start_date).days / 365
    months_passed = fraction_year_passed * 12
    return max(0, value * (12 - months_passed) / 12)


class StatementGeneratorApp:
    def __init__(self, root):
        """
        Initialize the application and its components.
        """
        self.root = root
        self.root.title("Statement Generator")

        # Define paths
        self.main_file_path = r"C:\folder\main_file.xlsx"  # Update this path to your main file
        self.moved_file_path = None

        # Load the main file into a DataFrame
        self.main_data = self.load_main_file()

        # Create tabbed interface
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill="both", expand=True)

        # Create tabs
        self.create_process_files_tab()
        self.create_edit_main_file_tab()

    # --- Utility Methods ---
    def load_main_file(self):
        """
        Load the main file into a DataFrame.
        """
        try:
            return pd.read_excel(self.main_file_path)
        except FileNotFoundError:
            messagebox.showerror("Error", f"Main file not found at {self.main_file_path}")
            self.root.destroy()
            return None

    def save_main_file(self):
        """
        Save the current state of the main file.
        """
        try:
            self.main_data.to_excel(self.main_file_path, index=False)
            messagebox.showinfo("Success", "Main file saved successfully.")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save the main file: {e}")

    def format_date_columns(self, dataframe):
        """
        Format date columns to display as YYYY-MM-DD.
        Handles cases where values are strings, datetime, or NaT.
        """
        formatted_data = dataframe.copy()
        for col in DATE_COLUMNS:
            if col in formatted_data.columns:
                formatted_data[col] = formatted_data[col].apply(
                    lambda x: x if isinstance(x, str) else (x.strftime("%Y-%m-%d") if pd.notna(x) else "")
                )
        return formatted_data

    def create_treeview(self, frame, data):
        """
        Create and populate a Treeview for displaying tabular data.
        """
        tree = ttk.Treeview(frame, show="headings", height=10)
        tree["columns"] = list(data.columns)

        # Configure Treeview columns
        for col in data.columns:
            tree.heading(col, text=col, anchor="w")
            tree.column(col, width=100, anchor="w")

        # Insert rows
        for _, row in data.iterrows():
            tree.insert("", "end", values=list(row))

        # Add scrollbars
        scroll_y = ttk.Scrollbar(frame, orient="vertical", command=tree.yview)
        scroll_y.grid(row=0, column=1, sticky="ns")
        tree.configure(yscrollcommand=scroll_y.set)

        scroll_x = ttk.Scrollbar(frame, orient="horizontal", command=tree.xview)
        scroll_x.grid(row=1, column=0, sticky="ew")
        tree.configure(xscrollcommand=scroll_x.set)

        tree.grid(row=0, column=0, sticky="nsew")
        return tree

    # --- Tab Creation Methods ---
    def create_edit_main_file_tab(self):
        """
        Create a tab for editing the main file with improved scrollbars, edit, and add functionalities.
        """
        frame = ttk.Frame(self.notebook)
        self.notebook.add(frame, text="Edit Main File")

        # Create and populate Treeview
        formatted_data = self.format_date_columns(self.main_data)
        self.tree = self.create_treeview(frame, formatted_data)

        # Save button
        save_button = ttk.Button(frame, text="Save Changes", command=self.save_changes_to_main_file)
        save_button.grid(row=2, column=0, pady=10, sticky="ew")

        # Edit selected row button
        edit_button = ttk.Button(frame, text="Edit Selected Row", command=self.edit_selected_row)
        edit_button.grid(row=3, column=0, pady=10, sticky="ew")

        # Add new row button
        add_button = ttk.Button(frame, text="Add New Row", command=self.add_new_row)
        add_button.grid(row=4, column=0, pady=10, sticky="ew")

        frame.grid_rowconfigure(0, weight=1)
        frame.grid_columnconfigure(0, weight=1)

    def create_process_files_tab(self):
        """
        Create a tab for processing the main and moved files.
        """
        frame = ttk.Frame(self.notebook)
        self.notebook.add(frame, text="Process Files")

        tk.Label(frame, text="Moved File (CSV):").grid(row=0, column=0, padx=10, pady=5)
        self.moved_file_label = tk.Label(frame, text="No file selected")
        self.moved_file_label.grid(row=0, column=1, padx=10, pady=5)
        tk.Button(frame, text="Browse", command=self.select_moved_file).grid(row=0, column=2, padx=10, pady=5)

        tk.Label(frame, text="Date:").grid(row=1, column=0, padx=10, pady=5)
        self.date_picker = Calendar(frame, selectmode="day", date_pattern="yyyy-mm-dd")
        self.date_picker.grid(row=1, column=1, columnspan=2, padx=10, pady=5)

        tk.Button(frame, text="Process Files", command=self.process_files).grid(row=2, column=1, padx=10, pady=10)

    # --- Editing Methods ---
    def edit_selected_row(self):
        """
        Edit the selected row in the Treeview.
        """
        selected_item = self.tree.focus()
        if not selected_item:
            messagebox.showwarning("Warning", "Please select a row to edit.")
            return

        current_values = self.tree.item(selected_item)["values"]
        popup = tk.Toplevel(self.root)
        popup.title("Edit Row")

        entries = {}
        for i, col in enumerate(self.tree["columns"]):
            tk.Label(popup, text=col).grid(row=i, column=0, padx=10, pady=5)
            entry = tk.Entry(popup)
            entry.insert(0, current_values[i])
            entry.grid(row=i, column=1, padx=10, pady=5)
            entries[col] = entry

        def save_changes():
            new_values = self.validate_and_format_entries(entries)
            if new_values:
                self.tree.item(selected_item, values=new_values)
                self.save_changes_to_main_file()
                popup.destroy()

        tk.Button(popup, text="Save Changes", command=save_changes).grid(row=len(self.tree["columns"]), column=0, columnspan=2, pady=10)

    def add_new_row(self):
        """
        Add a new row to the Treeview.
        Automatically saves the new row to the main file after adding.
        """
        popup = tk.Toplevel(self.root)
        popup.title("Add New Row")

        entries = {}
        for i, col in enumerate(self.tree["columns"]):
            tk.Label(popup, text=col).grid(row=i, column=0, padx=10, pady=5)
            entry = tk.Entry(popup)
            entry.insert(0, DEFAULT_VALUES.get(col, ""))  # Pre-fill with default values or leave blank
            entry.grid(row=i, column=1, padx=10, pady=5)
            entries[col] = entry

        def add_row():
            new_values = self.validate_and_format_entries(entries)
            if new_values:
                self.tree.insert("", "end", values=new_values)
                self.save_changes_to_main_file()
                popup.destroy()

        tk.Button(popup, text="Add Row", command=add_row).grid(row=len(self.tree["columns"]), column=0, columnspan=2, pady=10)

    def validate_and_format_entries(self, entries):
        """
        Validate and format entries before saving or adding a new row.
        """
        formatted_values = []
        for col, entry in entries.items():
            value = entry.get()

            # Validate and format date columns
            if col in DATE_COLUMNS:
                try:
                    value = datetime.strptime(value, "%Y-%m-%d").strftime("%Y-%m-%d")
                except ValueError:
                    messagebox.showerror("Error", f"Invalid date format for column {col}. Use YYYY-MM-DD.")
                    return None

            # Validate and format numeric columns
            elif col in ["Receive Rate", "Bid", "Offer", "PV", "SPREAD"]:
                try:
                    value = float(value)  # Convert to float
                    value = f"{value:.3f}"  # Format to 3 decimal places
                except ValueError:
                    messagebox.showerror("Error", f"Invalid numeric format for column {col}.")
                    return None

            # Add the validated and formatted value to the list
            formatted_values.append(value)

        return formatted_values

    def save_changes_to_main_file(self):
        """
        Save changes made in the Treeview back to the main file DataFrame.
        """
        self.main_data = pd.DataFrame(columns=self.tree["columns"])
        for row_id in self.tree.get_children():
            self.main_data.loc[len(self.main_data)] = self.tree.item(row_id)["values"]
        self.save_main_file()

    # --- Processing Methods ---
    def select_moved_file(self):
        """
        Open a file dialog to select the moved file.
        """
        self.moved_file_path = filedialog.askopenfilename(filetypes=[("CSV files", "*.csv")])
        self.moved_file_label.config(text=self.moved_file_path if self.moved_file_path else "No file selected")

    def process_files(self):
        """
        Process the main and moved files.
        """
        if not self.moved_file_path:
            messagebox.showerror("Error", "Please select a moved file.")
            return

        try:
            moved_data = pd.read_csv(self.moved_file_path)
            processed_data = self.preprocess_data(moved_data)
            self.display_in_excel(processed_data)
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}")

    def preprocess_data(self, moved_data):
        """
        Preprocess and merge the main and moved data.
        """
        moved_data['TRADEIDENTIFIER'] = moved_data['TRADEIDENTIFIER'].str[:7]
        self.main_data['TRADEIDENTIFIER'] = self.main_data['TRADEIDENTIFIER'].astype(str)
        main_data = self.main_data.merge(moved_data[['TRADEIDENTIFIER', 'PV']], on='TRADEIDENTIFIER', how='left')
        main_data['PV'] = main_data['PV'] * -1

        current_date = datetime.strptime(self.date_picker.get_date(), "%Y-%m-%d")

        def calculate_row(row):
            if pd.notna(row.get('P&L')) and pd.notna(row.get('TRADE DATE')):
                start_date = pd.to_datetime(row['TRADE DATE'])
                adjusted_pnl = calculate_amortization(start_date, current_date, row['P&L'])
                combined_value = row['PV'] + adjusted_pnl
                bid = combined_value - (2 / 3) * row.get('SPREAD', 0)
                offer = combined_value + (1 / 3) * row.get('SPREAD', 0)
                return pd.Series([adjusted_pnl, combined_value, bid, offer])
            return pd.Series([None, None, None, None])

        main_data[['Adjusted_P&L', 'Combined_Value', 'Bid', 'Offer']] = main_data.apply(calculate_row, axis=1)
        return main_data

    def display_in_excel(self, dataframe):
        """
        Display the processed DataFrame in Excel with formatting.
        """
        with tempfile.NamedTemporaryFile(delete=False, suffix=".xlsx") as tmp:
            temp_filename = tmp.name

        with pd.ExcelWriter(temp_filename, engine='openpyxl') as writer:
            dataframe.to_excel(writer, index=False, sheet_name="Processed Data")
            workbook = writer.book
            worksheet = writer.sheets["Processed Data"]

            for col_idx, col_name in enumerate(dataframe.columns, 1):
                if col_name in DATE_COLUMNS:
                    for row in range(2, len(dataframe) + 2):
                        worksheet.cell(row=row, column=col_idx).number_format = "mm/dd/yyyy"
                elif col_name in ["Notional", "Notional 2"]:
                    for row in range(2, len(dataframe) + 2):
                        worksheet.cell(row=row, column=col_idx).number_format = "$#,##0.00"
                elif col_name in ["Pay Rate"]:
                    for row in range(2, len(dataframe) + 2):
                        worksheet.cell(row=row, column=col_idx).number_format = "0.00%"
                elif col_name in ["Bid", "Offer"]:
                    for row in range(2, len(dataframe) + 2):
                        worksheet.cell(row=row, column=col_idx).number_format = "0.000%"

        os.startfile(temp_filename)


# Run the application
if __name__ == "__main__":
    root = tk.Tk()
    app = StatementGeneratorApp(root)
    root.mainloop()
